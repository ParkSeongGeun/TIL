## 개요

금일 네트워크 기본 개념(네트워크 정의, 토폴로지), OSI 7 Layer 중 물리 계층, 데이터 링크 계층에 대한 학습을 진행했습니다.

- 해당 과정에서 생긴 궁금증, 추가 학습을 진행한 내용입니다.

---

### 1. 네트워크 토폴로지: 연결선의 의미

토폴로지 다이어그램에서 선(링크)은 물리적 케이블만을 의미하지 않습니다. 선은 **네트워크 연결 자체**를 나타내며, 유선과 무선 모두를 포함할 수 있습니다.

#### **물리적 vs 논리적 토폴로지**

- **물리적 토폴로지 (Physical Topology):** 실제 물리적 연결을 나타냅니다.
  - **유선:** 이더넷 케이블, 광섬유 등
  - **무선:** Wi-Fi, 블루투스 등의 무선 연결
- **논리적 토폴로지 (Logical Topology):** 데이터가 어떻게 흐르는지를 나타내며, 물리적 연결 방식과 무관하게 네트워크 구조를 표현합니다.

#### **실제 사용 예시 (같은 스타 토폴로지라도)**

- **유선 네트워크:** 스위치에 각 컴퓨터가 이더넷 케이블로 연결
- **무선 네트워크:** 무선 AP에 각 기기가 Wi-Fi로 연결
- **혼합 네트워크:** 일부는 케이블, 일부는 무선으로 연결

> 핵심: 토폴로지 다이어그램의 선은 "연결이 존재한다"는 것을 보여주는 것이지, 반드시 물리적 케이블을 의미하는 것은 아닙니다.

---

### 2. 링 토폴로지 vs 토큰링 프로토콜

#### **링 토폴로지란? (구조)**

노드들이 도넛 모양처럼 원형으로 연결된 구조입니다. 각 노드는 좌우의 인접한 노드와만 연결되며, 단방향으로 데이터를 전송합니다 (`A → B → C → D → A`).

- **문제점:** 만약 A가 C에게, 동시에 B가 D에게 데이터를 보내려고 하면 충돌이 발생합니다. (링은 공유 매체이므로)

#### **토큰링 프로토콜이란? (규칙)**

링 토폴로지에서 충돌을 방지하기 위한 **매체 접근 제어 규칙**입니다.

**토큰(Token)의 역할**

- 링을 계속 순환하는 특별한 프레임이자 일종의 **"말하기 권한"**
- 토큰을 가진 노드만 데이터를 전송할 수 있음
- **두 가지 상태:**
  - `Free Token` (자유 토큰): 누구나 잡아서 사용 가능
  - `Busy Token` (사용중 토큰): 이미 누군가 사용중

**동작 과정 예시 (A가 C에게 데이터 전송)**

1. **A가 Free Token을 받음**
2. **A가 Busy Token + Data를 생성하여 링에 전송**
   - `[Busy Token + Data]` → B (통과) → C (수신)
3. **C가 데이터를 받고 ACK 표시**
   - `[Busy Token + Data + ACK]` → D (통과) → A (돌아옴)
4. **A가 확인 후 Free Token 생성**
   - A가 자신이 보낸 프레임을 다시 받아 ACK를 확인하고, 프레임을 링에서 제거한 후 Free Token을 내보냄
5. **이제 B가 Free Token을 받아 자신의 데이터 전송 가능**

### 정리

| **구분** | **링 토폴로지**        | **토큰링 프로토콜**      |
| -------- | ---------------------- | ------------------------ |
| **개념** | 물리적/논리적 구조     | 데이터 전송 규칙         |
| **의미** | 노드들이 원형으로 연결 | 토큰 기반 매체 접근 제어 |
| **충돌** | 구조만으로는 충돌 가능 | 토큰으로 충돌 방지       |

> 링 토폴로지는 "어떻게 연결되어 있는가(구조)"이고, 토큰링은 "그 구조에서 충돌 없이 통신하는 방법(프로토콜)"입니다.

---

### 3. Mesh vs Full-Connected

**Mesh 토폴로지**는 노드들이 그물망처럼 연결된 구조이며, 연결 정도에 따라 두 가지로 나뉩니다.

#### **1. Partial Mesh (부분 메시)**

- 일부 노드만 서로 연결된 형태.
- 모든 노드가 최소한 연결되어 있지만, 모든 쌍이 직접 연결된 것은 아닙니다.

#### **2. Full Mesh (완전 메시) = Full-Connected**

- 모든 노드가 서로 직접 연결된 형태.
- 어떤 두 노드를 선택해도 직접 연결 경로가 존재합니다.

#### **장단점 및 사용 예시**

- **Full Mesh:** 빠른 응답과 높은 가용성(한 경로가 고장 나도 우회 가능)이 장점이나 비용이 높음.
  - _사용:_ 데이터센터 코어 스위치, 통신사 백본, 금융 거래 시스템
- **Partial Mesh:** 비용 효율적이며 적절한 가용성 제공.
  - _사용:_ 일반 기업 네트워크, ISP 중간 계층

---

### 4. 유니캐스트와 MAC 주소 통신

MAC 주소 기반 통신은 **브로드캐스트 도메인** 내에서만 작동합니다. 이는 MAC 주소가 2계층(데이터링크)에서만 유효하기 때문입니다.

- 라우터는 브로드캐스트를 차단하므로 다른 네트워크로는 MAC 주소 기반 통신이 불가능합니다.

#### **ARP (Address Resolution Protocol)**

IP 주소(3계층)를 MAC 주소(2계층)로 변환해주는 프로토콜입니다.

**ARP 동작 과정**

1. **ARP Request (브로드캐스트):** 송신자가 네트워크 전체에 질문 (`목적지 MAC: FF:FF...`)
   - _"192.168.1.1의 MAC 주소가 뭐야?"_
2. **수신:** 스위치가 플러딩하여 모든 장치가 받음.
3. **ARP Reply (유니캐스트):** 해당 IP를 가진 장치만 응답 (`목적지 MAC: 송신자`)
   - _"나 192.168.1.1이야! 내 MAC은 R1-A야!"_
4. **ARP 테이블 저장:** 송신자는 정보를 캐싱하여 다음번에는 바로 사용.

---

### 5. 라우터를 통한 통신 - 전체 과정 (상세)

**시나리오:** A(192.168.1.10)가 C(192.168.2.20)에게 데이터 전송

#### **네트워크 구성**

- **Network A:** A (IP: ...10 / MAC: AA) ↔ 게이트웨이 (IP: ...1 / MAC: R1)
- **Router:** eth0 (MAC: R1) ↔ eth1 (MAC: R2)
- **Network B:** 게이트웨이 (IP: ...1 / MAC: R2) ↔ C (IP: ...20 / MAC: CC)

### 단계별 과정

**1단계: A의 판단**

- 목적지 IP와 내 IP의 서브넷 마스크 비교 → **"다른 네트워크다!"**
- 결론: 게이트웨이(192.168.1.1)로 보내야 함.

**2단계: 게이트웨이 MAC 확인**

- ARP를 통해 게이트웨이(192.168.1.1)의 MAC 주소 **R1**을 알아냄.

**3단계: A가 프레임 생성 (구간 1: A → 라우터)**

A는 최종 목적지가 C임에도 불구하고, **MAC 주소는 게이트웨이(R1)** 로 설정합니다.

```cpp
[이더넷 프레임]
├── [MAC 헤더]
│    출발지: AA (A)
│    목적지: R1 (게이트웨이)  <-- 핵심
└── [IP 패킷]
     출발지: 192.168.1.10 (A)
     목적지: 192.168.2.20 (C) <-- 최종 목적지 유지
```

**4~5단계: 라우터의 처리 (디캡슐화 & 라우팅 & 재캡슐화)**

1. **디캡슐화:** 목적지 MAC이 R1(나)이므로 받아들여 MAC 헤더를 제거합니다.
2. **라우팅:** IP 패킷의 목적지(192.168.2.20)를 보고 라우팅 테이블 확인 → `eth1`로 보내야 함을 결정.
3. **ARP:** 192.168.2.20(C)의 MAC 주소 **CC**를 확인.
4. **재캡슐화:** 새로운 MAC 헤더를 붙여 전송합니다.

```cpp
[새 이더넷 프레임]
├── [새 MAC 헤더]
│    출발지: R2 (라우터 eth1) <-- 변경됨
│    목적지: CC (C)           <-- 변경됨
└── [IP 패킷]
     출발지: 192.168.1.10 (A) <-- 유지됨
     목적지: 192.168.2.20 (C)
     TTL: 63 (1 감소)
```

**6~7단계: C에게 전달**

- C는 목적지 MAC이 CC(나)이고, 목적지 IP도 ...20(나)이므로 데이터를 받아 애플리케이션으로 전달합니다.

### 계층별 주소 변화 정리

- **MAC 주소 (2계층):** 각 구간(Hop)마다 변경됨. "다음 홉"까지만 책임짐.
- **IP 주소 (3계층):** 처음부터 끝까지 유지됨. "최종 목적지"를 나타냄.

---

### 6. 브로드캐스트 (Broadcast)

네트워크의 모든 장치에게 동시에 데이터를 전송하는 방식입니다.

- **주소:** `FF:FF:FF:FF:FF:FF` (모든 비트가 1)
- **범위:** **LAN (브로드캐스트 도메인)** 내로 제한됨.

### 스위치 vs 라우터의 처리

- **스위치:** 브로드캐스트 수신 시 **모든 포트로 플러딩** (통과).
- **라우터:** 브로드캐스트 수신 시 **차단**. 다른 네트워크로 넘기지 않음. (경계 역할)

### 왜 라우터는 차단하는가?

라우터가 브로드캐스트를 통과시킨다면, 불필요한 트래픽이 인터넷 전체로 퍼져 마비될 수 있습니다.

### 왜 `FF:FF...` 인가?

- 하드웨어적으로 구현하기 쉬움 (모든 비트가 켜져 있음 = 모두에게).
- NIC가 빠르게 판별 가능.

---

### 7. 애니캐스트 (Anycast)

여러 서버가 **같은 IP 주소**를 공유하고, 네트워크가 자동으로 **가장 가까운 서버**로 연결해주는 방식입니다.

### 동작 원리

1. **광고:** 서울, 도쿄, 뉴욕 서버가 모두 "나는 8.8.8.8이야!"라고 BGP로 광고.
2. **라우팅:** 라우터들은 각 서버까지의 거리를 계산해 라우팅 테이블 구성.
3. **연결:** 한국 사용자는 가장 가까운 서울 서버로, 일본 사용자는 도쿄 서버로 자동 연결.

### Google DNS 8.8.8.8 예시

전 세계 수십 개 데이터센터에 8.8.8.8 서버가 배치되어 있으며, 각 서버는 **엣지 서버(Edge Server)이자 캐시 서버** 역할을 합니다.

- **장점:** 낮은 지연시간(Latency), 고가용성(한 곳 죽으면 다른 곳으로 자동 우회), 부하 분산, DDoS 방어.

---

### 8. 패킷 교환 vs 회선 교환

### 회선 교환 (Circuit Switching)

- **방식:** 통신 전 전용 경로를 설정하고 독점 사용 (예: 전화망).
- **특징:** 품질이 일정하지만, 경로가 비어있어도 남이 못 써서 비효율적임.

### 패킷 교환 (Packet Switching)

- **방식:** 데이터를 작은 패킷으로 잘라 독립적으로 전송 (예: 인터넷).
- **특징:** 네트워크 자원을 공유하여 효율적이며, 장애 시 우회 가능.

### 핵심 비교

> 왜 인터넷은 패킷 교환인가?
>
> 데이터 통신은 버스트성(짧은 시간 폭주)이 강해 회선 교환은 낭비가 심합니다. 자원을 공유하고 장애에 강한 패킷 교환이 인터넷에 적합합니다.
